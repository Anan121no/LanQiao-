package _2016_B;
/*
 * 如下的10个格子
   +--+--+--+
   |  |  |  |
+--+--+--+--+
|  |  |  |  |
+--+--+--+--+
|  |  |  |
+--+--+--+
（如果显示有问题，也可以参看【图1.jpg】）
填入0~9的数字。要求：连续的两个数字不能相邻。
（左右、上下、对角都算相邻）
一共有多少种可能的填数方案？
请填写表示方案数目的整数。
注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。
全排，暴力剪枝
――――――――――――――――
版权声明：本文为CSDN博主「一叶之修」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_41793113/article/details/87976244
 */
public class _06方格填数 {
	public static void main(String[] args) {
		dfs(0);
		System.out.println(ans);
	}
	
	static int[] a = new int[] {0,1,2,3,4,5,6,7,8,9};
	static int ans=0;
	
	static void dfs(int m) {
		if(m>=10) {
			if(a[0]==a[1]-1 || a[0]==a[1]+1 || a[0]==a[4]-1 || a[0]==a[4]+1 || a[0]==a[3]-1 || a[0]==a[3]+1 || a[0]==a[5]-1 || a[0]==a[5]+1)
				return;
			if(a[1]==a[2]-1 || a[1]==a[2]+1 || a[1]==a[5]-1 || a[1]==a[5]+1 || a[1]==a[4]-1 || a[1]==a[4]+1 || a[1]==a[6]-1 || a[1]==a[6]+1)
				return;
			if(a[2]==a[6]-1 || a[2]==a[6]+1 || a[2]==a[5]-1 || a[2]==a[5]+1)
				return;
			if(a[3]==a[4]-1 || a[3]==a[4]+1 || a[3]==a[7]-1 || a[3]==a[7]+1 || a[3]==a[8]-1 || a[3]==a[8]+1)
				return;			
			if(a[4]==a[5]-1 || a[4]==a[5]+1 || a[4]==a[8]-1 || a[4]==a[8]+1 || a[4]==a[7]-1 || a[4]==a[7]+1 || a[4]==a[9]-1 || a[4]==a[9]+1)
				return;					
			if(a[5]==a[6]-1 || a[5]==a[6]+1 || a[5]==a[8]-1 || a[5]==a[8]+1 || a[5]==a[9]-1 || a[5]==a[9]+1)
				return;
			if(a[6]==a[9]-1 || a[6]==a[9]+1 || a[7]==a[8]-1 || a[7]==a[8]+1 || a[8]==a[9]-1 || a[8]==a[9]+1)
				return;	
			for(int i=0;i<=9;i++)
				System.out.print(a[i]+" ");
			System.out.println();
			ans++;
			return;
		}
		
		for(int i=m;i<10;i++) {
			swap(m,i);
			dfs(m+1);
			swap(m,i);
		}
		
	}
	
	static void swap(int i,int j) {
		int t = a[i];
		a[i] = a[j];
		a[j] = t;
		}
	}
